# Getting Started

kubectl-plugin-builder is a cli application that helps us to develop a kubectl plugin.
In general, a kubectl plugin can be implemented by these ways.

- shell script
- any other programming languages as you want to use
  - but maybe you need one the kubernetes api client library

I prefer you to use Go for implementing the plugins.
because most plugins are implemented for simplifying daily operaions of the k8s clusters,
so the plugins must have high maintainability and be easy to use, extend and understand.
[postfinance/kubectl-ns](https://github.com/postfinance/kubectl-ns), [corneliusweig/rakkess]() and many other impls are written by Go.
We know the practical way to implement a new plugin like those plugins.  

but the practical way needs some boilerplates.  

- initializing `kubernetes/cli-runtime` apis
  - api client
  - common cli flags like `-n/--namespace`
- following the [spf13/cobra](https://github.com/spf13/cobra)'s best-practice architecture

## Initialization a Project

first of all, you should make a directory that is the project's root.  

```shell
$ mkdir kubectl-demo && cd kubectl-demo
```

and now we can initialize the project with `kubectl-plugin-builder new` command!  

```shell
$ kubectl-plugin-builder new github.com/Drumato/kubectl-demo
Initialization Complete!
Run `go mod tidy` to install third-party modules.
$ go mod tidy # to install dependencies.
```

Let's see the directory's structure.
the builder generates some files for starting the development of the project.  

```shell
$ tree
.
├── cli.yaml
├── cmd
│   └── kubectl-demo
│       └── main.go
├── go.mod
├── internal
│   └── cmd
│       ├── demo
│       │   ├── command.go
│       │   └── handler.go
│       └── node.go
├── LICENSE
└── Makefile

5 directories, 8 files
```

- `cli.yaml` ... specifies the cli command and its architecture
  - kubectl-plugin-builder refers it and generate Go programs declaratively
- `cmd/<plugin-name>/main.go` ... this plugin's entrypoint
- `internal/cmd/node.go` ... defines `CLINodeOptions` interface
  - all commands in the project should implement the interface
- `internal/cmd/<command>` ... the root-command's package
  - `command.go` ... the declaration of `*cobra.Command`
    - the file is automatically created by builder so you mustn't edit this
  - `handler.go` ... the command's handlers and you can modify the codes
- `Makefile`
  - `build` ... the default task that builds the plugin
  - `generate` ... executes `kubectl-plugin-builder generate`
  - `test` ... executes the tests in the project
    - controls the verbosity with `TEST_VERBOSE={true,false}` argument
  - `install` ... install the plugin to `INSTALL_DIR`

Let's build the plugin and print the help.  

```shell
$ make # format + test + generate + build
$ ./kubectl-demo -h
Usage:
  demo [flags]

Flags:
  -h, --help   help for demo
```

## Modifying the command's handler

Next we'll see the generated file `internal/cmd/demo/command.go`.
the file includes the definition of `*cobra.Command`.

```go
// Code generated by kubectl-plugin-builder; DO NOT EDIT.

// LICENSE stripped
package demo

import (
        "github.com/spf13/cobra"

        "k8s.io/cli-runtime/pkg/genericclioptions"
)

var (
)

// WARNING: don't rename this function.
func NewCommand(streams *genericclioptions.IOStreams) *cobra.Command {
        c := &cobra.Command{
                Use:  "demo",

                Aliases: []string {
                },

                RunE: func(cmd *cobra.Command, args []string) error {
                        o := &options{streams: streams}
                        if err := o.Complete(cmd, args); err != nil {
                                return err
                        }

                        if err := o.Validate(); err != nil {
                                return err
                        }

                        return o.Run()
                },
        }

        return c
}
```

now you can see the command's handler consists of three methods.  

- `Complete(cmd *cobra.Command, args []string) error` ... it completes the parameters
- `Validate() error` ... it validates whether the parameters matches the command's context
- `Run() error` ... it runs the commands' core-behavior

Next we'll modify the handler in `internal/cmd/demo/handler.go`.
you may often edit the file because the file includes snippets of `Complete/Validate/Run`.

```go
// Code generated by kubectl-plugin-builder.

// LICENSE stripped
package demo

import (
        "fmt"

        "github.com/Drumato/kubectl-demo/internal/cmd"
        "github.com/spf13/cobra"
        "k8s.io/cli-runtime/pkg/genericclioptions"
)

// for statically checks options struct must implements the interface 
// at the compilation time.
var _ cmd.CLINodeOptions = &options{}

// options is used to hold the parameters about the command.
type options struct {
        cmd     *cobra.Command
        args    []string
        streams *genericclioptions.IOStreams
}

// Complete implements CLINodeOptions interface.
func (o *options) Complete(cmd *cobra.Command, args []string) error {
        o.cmd = cmd
        o.args = args
        return nil
}

// Validate implements CLINodeOptions interface.
func (o *options) Validate() error {
        return nil
}

// Run implements CLINodeOptions interface.
func (o *options) Run() error {
        _, err := fmt.Fprintln(o.streams.Out, o.cmd.Use)
        return err
}
```

Great!
if you want to change the command's behavior, just edit only the file.

## Declarative CLI generation

finally I'll introduce you `kubectl-plugin-builder generate` command.
the command generates go files declaratively and construct CLI architecture as you want.
Let's see the mechanism.  

let's see the initial content of `cli.yaml`.

```yaml
license: MIT
packageName: github.com/Drumato/kubectl-demo
root:
  name: demo
  year: 2021
  author: you
  defPath: internal/cmd/demo
  children:
  # you can add the subcommands into it
  # - name: subcmd
  #   defPath: internal/cmd/demo/subcmd
  #   year: 2021
  #   author: you
  #   description:
  #     short: "short description"
  #     long: "long description"
  #   aliases:
  #   - sc
  #   flags:
  #   - name: flag1
  #     type: string
  #     description: controls the subcmd's behavior
  #   children:
  #   - name: subsubcmd
  #     year: 2021
  #     author: you
  #     defPath: internal/cmd/demo/subcmd/subsubcmd
```

it seems just the command tree and easy to understand.
the builder refers it and use it as the code-generations parameters.  

- `name` ... the command name
- `year, author` ... used in license (placed at the top of source file)
- `defPath` ... the command package path
- `flags` ... the cli flags that you want to control the command's behavior with them
- `children` ... represents the relations btw parent-child

Now let's modify the specification and creates some new commands.  

```yaml
license: MIT
packageName: github.com/Drumato/kubectl-demo
root:
  name: demo
  year: 2021
  author: you
  defPath: internal/cmd/demo
  children:
  - name: subcmd
    defPath: internal/cmd/demo/subcmd
    year: 2021
    author: you
    description:
      short: "the sub-command for demo"
      long: "this is a sub command for demo"
    aliases:
    - sc
    flags:
    - name: flag1
      type: string
      description: controls the subcmd's behavior
    children:
    - name: subsubcmd
      year: 2021
      author: you
      defPath: internal/cmd/demo/subcmd/subsubcmd
```

and execute `kubectl-plugin-builder generate`.  

```shell
$ kubectl-plugin-builder generate
$ tree
.
├── cli.yaml
├── cmd
│   └── kubectl-demo
│       └── main.go
├── go.mod
├── go.sum
├── internal
│   └── cmd
│       ├── demo
│       │   ├── command.go
│       │   ├── handler.go
│       │   └── subcmd
│       │       ├── command.go
│       │       ├── handler.go
│       │       └── subsubcmd
│       │           ├── command.go
│       │           └── handler.go
│       └── node.go
├── kubectl-demo
├── LICENSE
└── Makefile

7 directories, 14 files
$ make
$ ./kubectl-demo -h
Usage:
  demo [flags]
  demo [command]

Available Commands:
  completion  generate the autocompletion script for the specified shell
  help        Help about any command
  subcmd      the sub-command for demo

Flags:
  -h, --help   help for demo

Use "demo [command] --help" for more information about a command.
$ ./kubectl-demo subcmd -h
this is a sub command for demo

Usage:
  demo subcmd [flags]
  demo subcmd [command]

Aliases:
  subcmd, sc

Available Commands:
  subsubcmd   

Flags:
      --flag1 string   controls the subcmd's behavior
  -h, --help           help for subcmd

Use "demo subcmd [command] --help" for more information about a command.
$ ./kubectl-demo subcmd subsubcmd -h
Usage:
  demo subcmd subsubcmd [flags]

Flags:
  -h, --help   help for subsubcmd
```

Now we can see these factors are achieved automatically.  

- command flags
- command description
- relations among each command

## More information

I recommend you to refer the examples directory that are placed at the top of this repository.  
