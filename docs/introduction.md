# Introduction

kubectl-plugin-builder is a CLI application that helps us to develop a kubectl plugin.
This document describes you to start development a kubectl plugin with the builder.
The builder is so small and simple so maybe you won't need to read the entire of this document :)  

- [Background](#background)
- [Getting Started](#getting-started)
- [More Information](#more-information)

### What is a kubectl plugin

You may know Kubernetes/k8s provides users several ways to extend k8s cluster(s).
The most famous mechanism is k8s custom controller.

Another one is **kubectl plugin**.
The extensibility is called **kubectl plugin**.
A kubectl plugin is just an executable that is placed in `PATH` kubectl can recognize.
Then you can use the plugin like `kubectl <plugin-name>`.
That mechanism unifies the operation btw kubectl and its plugins.
K8s operators just uses kubectl consistently.  

### How we start to develop a new plugin

In general, a kubectl plugin can be implemented by these ways.

- shell script
- any other programming languages as you want to use
  - but maybe you need one the kubernetes api client library

I prefer you to use Go for implementing the plugins.
because most plugins are implemented for simplifying daily operaions of the k8s clusters,
so the plugins must have high maintainability and be easy to use/extend/understand.
[postfinance/kubectl-ns](https://github.com/postfinance/kubectl-ns), [corneliusweig/rakkess]() and many other impls are written by Go.
there are many tips to implement a new plugin.  

- unifies each command's structure into **CVR** model
  - CVR stands for `Complete/Validate/Run`
- capture each command's I/O into the in-memory buffer
- use `github.com/spf13/cobra` to construct a CLI application easily
- use `kubernetes/cli-runtime`

## What kubectl-plugin-builder achieves

We know the practical way needs a few boilerplates.  

- initializing `kubernetes/cli-runtime` components
  - api client
  - common CLI flags like `-n/--namespace`
- following the [spf13/cobra](https://github.com/spf13/cobra)'s best-practice architecture

For K8s operators, they only want to focus on the core mechanism of the plugin.
So kubectl-plugin-builder provides some features to avoid boilerplates like above.

- following the best-practices **by default**
  - `kubernetes/cli-runtime` initialization
  - [spf13/cobra](https://github.com/spf13/cobra) CLI construction
- each command's output mode
  - you can select the command's output format with specifying `--output-mode=<normal/json/yaml/etc>`

These features will be described later.  

---

## Getting Started

This section I'll describe how to start development with kubectl-plugin-builder.  

### Initialization a Project

First of all we should execute `kubectl-plugin-builder new <module_name>` to initialize a project.  

```shell
$ mkdir kubectl-demo && cd kubectl-demo
$ kubectl-plugin-builder new github.com/Drumato/kubectl-demo
Initialization Complete!
Run `go mod tidy` to install third-party modules.
```

Now you can see the output that wants us to execute `go mod tidy` command.
and after it we can build the project.
But before building, Let's see the project's structure.  

```shell
$ tree
.
├── cli.yaml
├── cmd
│   └── kubectl-demo
│       └── main.go
├── go.mod
├── internal
│   └── cmd
│       ├── demo
│       │   ├── command.go
│       │   └── handler.go
│       └── node.go
├── LICENSE
└── Makefile

5 directories, 8 file
```

Some files generated automatically and each file is so simple and trivial.  

- `cli.yaml` ... The specification of the project's CLI architecture
  - this files is used in the `make generate` task
- `LICENSE` ... The license file
  - The builder only support MIT license for now(but it's easy to extend)
- `Makefile` ... Declares some tasks and users can use them for convenient development
  - `format` ... formats all Go packages under the project
  - `test` ... tests all Go packages under the project
  - `build` ... builds the plugin
  - `generate` ... generates Go programs declaratively
  - `install` ... install the plugin into `INSTALL_DIR` (default: `/usr/bin`)
- `internal/cmd/node.go` ... defines `CLINodeOptions` interface
  - all commands should implement the interface
- `internal/cmd/demo` ... defines the root command
  - if the command name is started with `kubectl-` the builder strips it
- `cmd/kubectl-demo/main.go` ... the plugin's entrypoint

For now we can build the plugin with `make`.  

```shell
$ go mod tidy
$ make > /dev/null
$ ./kubectl-demo -h
```

Now let's dive into each Go program!
Here's the source of `internal/cmd/node.go`.  

```go
// Code generated by kubectl-plugin-builder.
/* LICENSE header(stripped) */
package cmd

import (
        "github.com/spf13/cobra"
)

type CLINodeOptions interface {
        Complete(cmd *cobra.Command, args []string) error
        Validate() error
        Run() error
}

type OutputMode = string

const (
        OutputModeNormal OutputMode = "normal"
        // OutputModeJSON
        // OutputModeYAML
)
```

You can see the definition of `CLINodeOptions` , all commands in the project references the interface and implements it.
The interface guide us to implement plugin commands in the practical way.
Almost famous plugins follow the architecture.  

- [kubectl-ns](https://github.com/postfinance/kubectl-ns/blob/v1.0.6/cmd/ns.go)
- [ksniff](https://github.com/eldadru/ksniff/blob/v1.6.1/pkg/cmd/sniff.go)

And `OutputMode` is used for switching the command's output.
Let's look at `internal/cmd/demo/command.go`.  

```go
// Code generated by kubectl-plugin-builder; DO NOT EDIT.

/* LICENSE HEADER(stripped) */
package demo

import (
        "github.com/spf13/cobra"

        "k8s.io/cli-runtime/pkg/genericclioptions"
        "github.com/Drumato/kubectl-demo/internal/cmd"
)

var (
        // demoOutputModeFlag provides 
        // user-passed option to options.
        demoOutputModeFlag string
)

// WARNING: don't rename this function.
func NewCommand(streams *genericclioptions.IOStreams) *cobra.Command {
        c := &cobra.Command{
                Use:  "demo",

                Aliases: []string {
                },
                Short: "short description",
                Long: "long description",

                RunE: func(cmd *cobra.Command, args []string) error {
                        o := &options{streams: streams}
                        if err := o.Complete(cmd, args); err != nil {
                                return err
                        }

                        if err := o.Validate(); err != nil {
                                return err
                        }

                        return o.Run()
                },
        }

        hangChildrenOnCommand(c, streams)
        defineCommandFlags(c)

        return c
}

// hangChildrenOnCommand enumerates command's children and attach them into it.
func hangChildrenOnCommand(c *cobra.Command, streams *genericclioptions.IOStreams) {
}

// defineCommandFlags declares primitive flags.
func defineCommandFlags(c *cobra.Command) {
        c.Flags().StringVarP(
                &demoOutputModeFlag,
                "output",
                "o",
                cmd.OutputModeNormal,
                "the command's output mode",
        )
}
```

there are some identifiers you should understand.  

- `demoOutputModeFlag` ... the flag that controls the command's output mode
- `NewCommand()` ... define the command
  - please edit `cli.yaml` if you want to modify the command's description/aliases/etc
- `hangChildrenOnCommand()` ... enumerates the command's children and attach them into it
- `defineCommandFlags()` ... define command flags and attach them into the command

### Edit the command

If you want some new flags, you can add by editing `cli.yaml`

```yaml
license: MIT
packageName: github.com/Drumato/kubectl-demo
root:
  name: demo
  year: 2021
  author: you
  defPath: internal/cmd/demo
  flags:
  - name: flag1 # added
    type: string
    description: controls root command behavior
  - name: flag2 # added
    type: string
    description: controls root command behavior
  children:
```

And just execute `make` and you can see flags!

```shell
$ make > /dev/null 
$ ./kubectl-demo -h
Usage:
  demo [flags]

Flags:
      --flag1 string    controls root command behavior
      --flag2 string    controls root command behavior
  -h, --help            help for demo
  -o, --output string   the command's output mode (default "normal")
```

### Declare a new command

If you want to add a new command into the plugin,
I prefer you to use `kubectl-plugin-builder add` instead of editing directly.

```shell
$ kubectl-plugin-builder add subcmd1 demo
$ make > /dev/null 
$ ./kubectl-demo -h
Usage:
  demo [flags]
  demo [command]

Available Commands:
  completion  generate the autocompletion script for the specified shell
  help        Help about any command
  subcmd1     short description

Flags:
      --flag1 string    controls root command behavior
      --flag2 string    controls root command behavior
  -h, --help            help for demo
  -o, --output string   the command's output mode (default "normal")

Use "demo [command] --help" for more information about a command.
```

the command has some validators.  

```shell
$ kubectl-plugin-builder add subcmd1 demo # already declared
ERROR: the name 'subcmd1' already used in a child of demo cmd
$ kubectl-plugin-builder add subcmd2 invalid # parent doesn't exist
ERROR: CMD_PARENT must exist on the cli.yaml
```

---

## More Information
